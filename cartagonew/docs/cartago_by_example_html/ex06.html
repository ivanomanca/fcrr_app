<p style="text-align: justify;">Sometimes it is useful to implement operations that trigger the asynchronous execution of other operations inside the artifact, which are typically long-term. For instance: a clock artifact can have the <code>start</code> operation, triggering the execution of a long-term <code>counting</code> operation. Such operations are typically <strong>internal</strong>, i.e. not (necessarily) part of the usage interface, and are annotated with <code>@INTERNAL_OPERATION</code>. To trigger the execution of an internal operation the <code>execInternalOp</code> primitive is provided.</p>
<p style="text-align: justify;">In the following example, an agent creates a clock and uses it.</p>

<blockquote style="text-align: justify;">
<pre>MAS example06_clock {

  environment:
  c4jason.CartagoEnvironment

  agents:
  clock_user agentArchClass c4jason.CAgentArch;

  classpath: "../../../lib/cartago.jar";"../../../lib/c4jason.jar";
}</pre>
</blockquote>
<p style="text-align: justify;">The clock artifact has two usage interface operations - <code>start</code> and <code>stop</code> - and an internal operation<code> count</code>, triggered by <code>start</code>:</p>

<blockquote style="text-align: justify;">
<pre>public class Clock extends Artifact {

  boolean counting;
  final static long TICK_TIME = 100;

  void init(){
    counting = false;
  }

  @OPERATION void start(){
    if (!counting){
      counting = true;
      execInternalOp("count");
    } else {
      failed("already_counting");
    }
  }

  @OPERATION void stop(){
    counting = false;
  }

  @INTERNAL_OPERATION void count(){
    while (counting){
      signal("tick");
      await_time(TICK_TIME);
    }
  }
}</pre>
</blockquote>
<p style="text-align: justify;"><strong>Highlights:</strong></p>

<ul style="text-align: justify;">
	<li><strong>Timed await:</strong> <code>await_time</code> primitive belongs to the <code>await</code> primitives: it suspends the execution of the operation until the specified time (in milliseconds) has elapsed (from now). Like in the <code>await</code> case, by suspending the operation, the artifact is made accessible to agents for executing operations and possible changes to its observable state are committed and made observable.</li>
</ul>
<p style="text-align: justify;">The agent starts a clock, then reacts to ticks generated by it for a certain number of times, and finally  stopping it.</p>

<blockquote style="text-align: justify;">
<pre>!test_clock.

+!test_clock
  &lt;- makeArtifact("myClock","c4jexamples.Clock",[],Id);
     focus(Id);
     +n_ticks(0);
     start;
     println("clock started.").

@plan1
+tick: n_ticks(10)
  &lt;- stop;
     println("clock stopped.").

@plan2 [atomic]
+tick: n_ticks(N)
  &lt;- -+n_ticks(N+1);
     println("tick perceived!").</pre>
</blockquote>
<p style="text-align: justify;"><strong>Highlights:</strong></p>

<ul style="text-align: justify;">
	<li style="text-align: justify;"> <strong>Controllable processes:</strong> these features make it possible to exploit artifacts also to implement controllable
long-term processes, without the need to use agents for this purpose (e.g. clock agent).</li>
</ul>