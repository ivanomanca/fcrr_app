<p style="text-align: justify;">In order to realise  complex operations, a family of primitives (called <code>await</code>) is provided to<strong> suspend</strong> the execution of an operation until some specified condition is met, breaking the execution of an operation in multiple transactional steps. By suspending the execution of an operation, other operations can be invoked before the current one is terminated. When the specified condition holds and no operations are in execution, the suspended operation is resumed. Complex operations which can be implemented by using this mechanism include:</p>

<ul style="text-align: justify;">
	<li> long-term operations which need not to block the use of the artifact;</li>
	<li> concurrent operations i.e. operations whose execution must overlap, which are essential for realising coordination mechanisms and functionalities.</li>
</ul>
<p style="text-align: justify;">In the following example, two agents share and concurrently use an artifact, which provides an  operation using this mechanism.</p>

<blockquote style="text-align: justify;">
<pre>MAS example05_complexop {

    environment:
    c4jason.CartagoEnvironment

    agents:
    complexop_userA agentArchClass c4jason.CAgentArch;
    complexop_userB agentArchClass c4jason.CAgentArch;

    classpath: "../../../lib/cartago.jar";"../../../lib/c4jason.jar";
}</pre>
</blockquote>
<p style="text-align: justify;">The artifact used by the two agents has the following code:</p>

<blockquote style="text-align: justify;">
<pre>public class ArtifactWithComplexOp extends Artifact {

  int internalCount;

  void init(){
    internalCount = 0;
  }

  @OPERATION void complexOp(int ntimes){
    doSomeWork();
    signal("step1_completed");
    await("myCondition", ntimes);
    signal("step2_completed",internalCount);
  }

  @GUARD boolean myCondition(int ntimes){
    return internalCount &gt;= ntimes;
  }

  @OPERATION void update(int delta){
    internalCount+=delta;
  }

  private void doSomeWork(){}

}</pre>
</blockquote>
<p style="text-align: justify;">In <code>complexOp</code> first we do some work, then we generate a signal <code>step1_completed</code>, and after that, by means of <code>await</code>, we suspend the execution of the operation until the condition defined by the  guard method<code> myCondition</code> -  whose name (and parameters, if needed) are specified as parameters of the <code>await </code>primitive - holds.</p>
<p style="text-align: justify;">The effect is to suspend the execution of the operation until the value of <code>internalCount</code> is greater than or equal to the value specified by the <code>complexOp</code> <code>ntimes</code> parameter. Besides <code>complexOp</code>, the <code>update</code> operation is provided to increment the internal counter. In the example one agent - <code>complexop_userA</code> - executes a <code>complexOp</code> and the other agent -<code> complexop_userB</code> - repeatedly execute <code>update</code>. The action and plan of the first agent is suspended until the second agent has executed a number of updates which is sufficient to resume the <code>complexOp</code> operation. Here it is the <code>complexop_userA</code> source code:</p>

<blockquote style="text-align: justify;">
<pre>!do_test.

@do_test
+!do_test
  &lt;- println("[userA] creating the artifact...");
     makeArtifact("a0","c4jexamples.ArtifactWithComplexOp",[],Id);
     focus(Id);
     println("[userA] executing the action...");
     complexOp(10);
     println("[userA] action completed."). 

+step1_completed
  &lt;- println("[userA] first step completed.").

+step2_completed(C)
  &lt;- println("[userA] second step completed: ",C).</pre>
</blockquote>
<p style="text-align: justify;">It is worth noting that the agent reacts to <code>step1_completed</code> signal generated by the artifact, printing a message on the console, even if the <code>do_test</code> plan execution is suspended waiting for <code>complexOp(10) </code>action completion. <code>complexop_userB</code> source code:</p>

<blockquote style="text-align: justify;">
<pre>!do_test.

+!do_test
  &lt;- !discover("a0");      !use_it(10).            +!use_it(NTimes) : NTimes &gt; 0
  &lt;- update(3);
     println("[userB] updated.");
     !use_it(NTimes - 1).

+!use_it(0)
  &lt;- println("[userB] completed.").

+!discover(ArtName)
  &lt;- lookupArtifact(ArtName,_).
-!discover(ArtName)
  &lt;- .wait(10);
     !discover(ArtName).</pre>
</blockquote>
<p style="text-align: justify;">The agent simply executes for 10 times the <code>update</code> operation. By running the example it is possible to see the interleaving of the agent actions.</p>

<h3 style="text-align: justify;">Highlights:</h3>
<ul style="text-align: justify;">
	<li> <strong>Concurrency:</strong> the execution of the operations overlaps in time: however always only one operation step is in execution at a time, so no interferences can occur in accessing and modifying artifact state</li>
	<li style="text-align: justify;"> <strong>Transactionality and Observability:</strong> by executing <code>await</code>, all the changes to the observable properties done so far by the operation are committed.</li>
</ul>


<p style="text-align: justify;">Here we show an example of how to exploit structured operations to implement a coordination artifact, a simple<strong> tuple space</strong>, and its usage to solve the dining philosophers coordination problem. The <code>in</code> and <code>rd</code> operations (that corresponds to the <code>in</code> and <code>rd</code> Linda primitives) are easily implemented exploiting the <code>await</code> mechanism:</p>

<blockquote style="text-align: justify;">
<pre>public class TupleSpace extends Artifact {

  TupleSet tset;

  void init(){
    tset = new TupleSet();
  }

  @OPERATION void out(String name, Object... args){
    tset.add(new Tuple(name,args));
  }

  @OPERATION void in(String name, Object... params){
    TupleTemplate tt = new TupleTemplate(name,params);
    await("foundMatch",tt);
    Tuple t = tset.removeMatching(tt);
    bind(tt,t);
  }

  @OPERATION void rd(String name, Object... params){
    TupleTemplate tt = new TupleTemplate(name,params);
    await("foundMatch",tt);
    Tuple t = tset.readMatching(tt);
    bind(tt,t);
  }

  private void bind(TupleTemplate tt, Tuple t){
    Object[] tparams = t.getContents();
    int index = 0;
    for (Object p: tt.getContents()){
      if (p instanceof OpFeedbackParam){
        ((OpFeedbackParam) p).set(tparams[index]);
      }
      index++;
    }
  }

  @GUARD boolean foundMatch(TupleTemplate tt){
    return tset.hasTupleMatching(tt);
  }
}</pre>
</blockquote>
<p style="text-align: justify;">(The description of <code>Tuple</code>, <code>TupleTemplate</code> and <code>TupleSet</code> classes is omitted).</p>
<p style="text-align: justify;">This is actually the implementation of the <code>blackboard</code> tuple space artifact available by default in any workspace. It follows a solution to the dining philosophers problem using a tuple space:</p>

<blockquote style="text-align: justify;">
<pre>MAS example05a_philo {

    environment:
    c4jason.CartagoEnvironment

    agents:
    waiter agentArchClass c4jason.CAgentArch;
    philo agentArchClass c4jason.CAgentArch #5;

    classpath: "../../../lib/cartago.jar";"../../../lib/c4jason.jar";
}</pre>
</blockquote>
<p style="text-align: justify;">The MAS is composed by a waiter agent and five philosophers. The waiter is responsible of preparing the environment, injecting the tuples representing the forks (five <code>fork(F)</code> tuples) and tickets (four <code>ticket</code> tuples), which allow for avoiding deadlocks.</p>

<blockquote style="text-align: justify;">
<pre>philo(0,"philo1",0,1).
philo(1,"philo2",1,2).
philo(2,"philo3",2,3).
philo(3,"philo4",3,4).
philo(4,"philo5",4,0).

!prepare_table.

+!prepare_table
  &lt;- for ( .range(I,0,4) ) {
       out("fork",I);
       ?philo(I,Name,Left,Right);
       out("philo_init",Name,Left,Right);
     };
     for ( .range(I,1,4) ) {
       out("ticket");
     };
     println("done.").</pre>
</blockquote>
<p style="text-align: justify;">The philosophers repeatedly get a couple of forks, use them to eat, and then release them. Before taking the forks they must get a ticket, which is released then after releasing the forks.</p>

<blockquote style="text-align: justify;">
<pre>!start.

+!start
  &lt;- .my_name(Me);
     in("philo_init",Me,Left,Right);
     +my_left_fork(Left);
     +my_right_fork(Right);
     println(Me," ready.");
     !!living.

+!living
 &lt;- !thinking;
    !eating;
    !!living.

+!eating
 &lt;- !acquireRes;
    !eat;
    !releaseRes.

+!acquireRes :
  my_left_fork(F1) &amp; my_right_fork(F2)
  &lt;- in("ticket");
     in("fork",F1);
     in("fork",F2).

+!releaseRes:
  my_left_fork(F1) &amp; my_right_fork(F2)
 &lt;-  out("fork",F1);
     out("fork",F2);
     out("ticket").

+!thinking
  &lt;- .my_name(Me); println(Me," thinking").
+!eat
  &lt;- .my_name(Me); println(Me," eating").</pre>
</blockquote>
<p style="text-align: justify;"><strong>Highlights</strong></p>

<ul style="text-align: justify;">
	<li> no one created the tuple space artifact, since it is already available in the workspace by default.</li>
</ul>